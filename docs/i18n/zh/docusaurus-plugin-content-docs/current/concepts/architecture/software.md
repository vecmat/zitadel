---
title: 软件
---

ZITADEL有两个基本模式。 事件来源（ES）和指挥与查询责任分离（CQRS）。 由于事件来源于ZITADEL的性质，它具有独特的能力，能够产生一个强有力的审计线索，对其资源所发生的事情进行追踪。 不影响储存成本或审计线索长度。

ES和CQRS 的结合使ZITADEL最终能够保持一致，我们认为，这在许多方面是一个很大的好处。 它使我们能够建立一个记录来源(SOR)，这是所有计算状态的唯一真理点。 SOR需要安全交易，以确保所有操作符合要求。 您可以在我们的 [ES 文档](../eventstore/overview) 中阅读更多关于这个问题的信息。

每个ZITADEL二进制文件包含所有服务流量 所需的组件。通过提供 API ，渲染图形界面，事件和任务的背景处理。 这一切都是一种(AiO)方法，使得ZITADEL的运作变得简单。

## 软件结构

ZITADEL的软件结构是围绕不同层次的多个组件而构建的。 本章应该让你了解组件以及不同的图层。

![软件结构](/img/zitadel_software_architecture.png)

### 服务图层

服务层包括可能接触到ZITADEL消费者的所有部分。

#### HTTP 服务器

http服务器负责下列函数：

- 服务于GUI 称为ZITADEL控制台
- 为静态资源服务
- 服务器端渲染html (登录，密码重置，验证，...)

#### API 服务器

API层由ZITADEL提供的多个API组成。 每个项目都有一个专门的目的。 ZITADEL的所有API总是以gRCP、gRPPC-web 和REST服务形式提供。 唯一例外是 [OpenID Connect & OAuth](/docs/apis/openidoauth/endpoints) 和 [Asset API](/docs/apis/introduction#assets) 因其独特性质。

- [OpenID Connect & OAuth](/docs/apis/openidoauth/endpoints) - 允许请求 ZITADEL的身份验证和授权
- [SAML](/docs/apis/saml/endpoints) - 允许通过SAML标准请求ZITADEL的身份验证和授权
- [身份验证 API](/docs/apis/introduction#authentication) - 允许用户在自己的上下文中执行操作
- [管理 API](/docs/apis/introduction#management) - 允许管理员或机器在组织一级管理ZITADEL资源
- [管理 API](/docs/apis/introduction#administration) - 允许管理员或机器在一个实例级别管理ZITADEL资源
- [系统 API](/docs/apis/introduction#system) - 允许创建和更改新的 ZITADEL 实例
- [Asset API](/docs/apis/introduction#assets) - 用于上传和下载静态资产

### 核心图层

#### 命令

指挥部有一些独特的要求，包括：

- 交易安全是一个 MUST
- 可用性很高

> 当我们按照联合呼吁程序的理论对此进行分类时，我们将选择一致和可用的办法，但将分治容忍搁置一边。

##### 命令处理器

指挥处理程序接收所有更改ZITADEL管理资源的操作。 例如，如果用户更改了他的名字。 API Layer 将通过API调用接收的指令传递给命令处理程序以便进一步处理。 然后，命令处理程序负责创建必要的命令。 在创建命令后，命令将它们交给命令验证。

##### 命令验证

通过收到的命令，命令验证将执行业务逻辑来验证是否可以采取某些行动。 例如，如果用户真的可以更改他的名字在命令验证过程中进行验证。 如果它成功, 命令验证将创建反映更改的事件。 这些事件现在正在交给储存层储存。

#### 事件

ZITADEL以两种方式处理事件。 应在近乎实时处理的事件由内存子系统处理。 一些事件是在假冒者负责的背景处理中手工处理的。

##### Pub Sub

pub 子系统作业是为了通过为预测提供不断的事件流来随时更新查询视图。 我们在ZITADEL中建立的公共子系统通过将事件放入其用户的记忆队列而起作用。 没有必要从子系统得到具体的保证。 由于SOR是ES系统，可以在不丢失数据的情况下重试一切。 如果发生错误，事件可以通过以下两种方式重新应用：

- 下一个事件可能触发投影以应用整个差异
- 伪装者以预定方式处理背景清理工作

> 决定纳入一个不需要具体保障的内部子系统是一种故意的选择。 我们认为，额外的外部服务如MQ系统造成的损失对ZITADEL的使用难度及其可获得的保证产生了不利影响。 ZITADEL的作者之一作了他的论点，对这种方法进行了测试，以对照既定的管理信息系统进行检验。

##### Spooler

假冒者作业是为了保持查询视图更新，或至少看到它在事件仓库后面没有太大的滞后。 每个查询视图都有自己的伪装器，负责寻找与生成查询视图相关的事件。 它通过触发有关预测来做到这一点。 当某人可以查询数据集而不是单个ID时，Sopoer就特别必要。

> 每个视图只能有一个变幻剂，但假冒者是动态当选的领导者。 即使假冒者崩溃，也会在短时间内被替换。

#### 预测

预测负责为查询方或为分析目的使数据正常化。 它们一般都是通过预定的假冒者或子订阅而得到援引的。

当他们收到事件时，他们将创建其正常化对象，然后将其存储到查询视图和存储层。

#### 查询

查询方负责回答关于数据的读取请求。 它有一些独特的要求，包括：

- 它需要简单的查询
- 短响应时间是一个 MUST (api 服务器上80%of 查询不到100毫秒)
- 即使在负载过多的情况下，可用性仍然很高
- 查询视图能够在大多数请求中持续使用

> 当我们使用 CAP 理论分类时，我们会选择 **可用** 和 **性能** ，但留空 **一致性**

##### 查询处理程序

查询处理程序接收所有已读相关操作。 这些可以是查询或简单的 `getByid` 调用。 当接收查询时，它将继续将其传递到将调用数据库并返回数据集的存储库。 如果请求调用了一个特定ID，则该通话将在大多数情况下重新验证为事件仓库。 这是通过触发投影来实现的，目的是确保一个ID的最后序列被加载到查询视图。

> 查询方有权动态检查事件仓库在某个ID上的新事件，以确保毫不拖延地做出一致反应。

##### 查询视图

查询视图负责用命令处理器的请求查询存储层。 它还负责执行授权检查。 检查请求是否有效并能被解答。

### 存储图层

由于ZITADEL本身是完全建成的，因此只需要储存一层储存物品。 ZITADEL的储存层负责多件物品。 例如：

- 通过多个服务器、数据中心或区域传播高可用性数据
- 保证指挥方的高度一致性
- 保证查询侧的良好查询性能。
- 在特定数据中心或地区储存数据的能力，以便数据存留(这只能由CockroachDB Cloud或企业支持)
- 为灾后恢复而备份和恢复操作

ZITADEL目前支持CockroachDB作为首选储存，因为它完全符合ZITADEL的需要。 PostgreSQL 支持目前处于测试阶段。
